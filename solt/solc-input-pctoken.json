{
    "language": "Solidity",
    "sources": {
        "./contracts/configurable-rights-pool/contracts/PCToken.sol": {
            "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.6.12;\n\n// Imports\n\nimport \"../libraries/BalancerSafeMath.sol\";\nimport \"../interfaces/IERC20.sol\";\n\n// Contracts\n\n/* solhint-disable func-order */\n\n/**\n * @author Balancer Labs\n * @title Highly opinionated token implementation\n*/\ncontract PCToken is IERC20 {\n    using BalancerSafeMath for uint;\n\n    // State variables\n    string public constant NAME = \"Balancer Smart Pool\";\n    uint8 public constant DECIMALS = 18;\n\n    // No leading underscore per naming convention (non-private)\n    // Cannot call totalSupply (name conflict)\n    // solhint-disable-next-line private-vars-leading-underscore\n    uint internal varTotalSupply;\n\n    mapping(address => uint) private _balance;\n    mapping(address => mapping(address => uint)) private _allowance;\n\n    string private _symbol;\n    string private _name;\n\n    // Event declarations\n\n    // See definitions above; must be redeclared to be emitted from this contract\n    event Approval(address indexed owner, address indexed spender, uint value);\n    event Transfer(address indexed from, address indexed to, uint value);\n\n    // Function declarations\n\n    /**\n     * @notice Base token constructor\n     * @param tokenSymbol - the token symbol\n     */\n    constructor (string memory tokenSymbol, string memory tokenName) public {\n        _symbol = tokenSymbol;\n        _name = tokenName;\n    }\n\n    // External functions\n\n    /**\n     * @notice Getter for allowance: amount spender will be allowed to spend on behalf of owner\n     * @param owner - owner of the tokens\n     * @param spender - entity allowed to spend the tokens\n     * @return uint - remaining amount spender is allowed to transfer\n     */\n    function allowance(address owner, address spender) external view override returns (uint) {\n        return _allowance[owner][spender];\n    }\n\n    /**\n     * @notice Getter for current account balance\n     * @param account - address we're checking the balance of\n     * @return uint - token balance in the account\n     */\n    function balanceOf(address account) external view override returns (uint) {\n        return _balance[account];\n    }\n\n    /**\n     * @notice Approve owner (sender) to spend a certain amount\n     * @dev emits an Approval event\n     * @param spender - entity the owner (sender) is approving to spend his tokens\n     * @param amount - number of tokens being approved\n     * @return bool - result of the approval (will always be true if it doesn't revert)\n     */\n    function approve(address spender, uint amount) external override returns (bool) {\n        /* In addition to the increase/decreaseApproval functions, could\n           avoid the \"approval race condition\" by only allowing calls to approve\n           when the current approval amount is 0\n        \n           require(_allowance[msg.sender][spender] == 0, \"ERR_RACE_CONDITION\");\n\n           Some token contracts (e.g., KNC), already revert if you call approve \n           on a non-zero allocation. To deal with these, we use the SafeApprove library\n           and safeApprove function when adding tokens to the pool.\n        */\n\n        _allowance[msg.sender][spender] = amount;\n\n        emit Approval(msg.sender, spender, amount);\n\n        return true;\n    }\n\n    /**\n     * @notice Increase the amount the spender is allowed to spend on behalf of the owner (sender)\n     * @dev emits an Approval event\n     * @param spender - entity the owner (sender) is approving to spend his tokens\n     * @param amount - number of tokens being approved\n     * @return bool - result of the approval (will always be true if it doesn't revert)\n     */\n    function increaseApproval(address spender, uint amount) external returns (bool) {\n        _allowance[msg.sender][spender] = BalancerSafeMath.badd(_allowance[msg.sender][spender], amount);\n\n        emit Approval(msg.sender, spender, _allowance[msg.sender][spender]);\n\n        return true;\n    }\n\n    /**\n     * @notice Decrease the amount the spender is allowed to spend on behalf of the owner (sender)\n     * @dev emits an Approval event\n     * @dev If you try to decrease it below the current limit, it's just set to zero (not an error)\n     * @param spender - entity the owner (sender) is approving to spend his tokens\n     * @param amount - number of tokens being approved\n     * @return bool - result of the approval (will always be true if it doesn't revert)\n     */\n    function decreaseApproval(address spender, uint amount) external returns (bool) {\n        uint oldValue = _allowance[msg.sender][spender];\n        // Gas optimization - if amount == oldValue (or is larger), set to zero immediately\n        if (amount >= oldValue) {\n            _allowance[msg.sender][spender] = 0;\n        } else {\n            _allowance[msg.sender][spender] = BalancerSafeMath.bsub(oldValue, amount);\n        }\n\n        emit Approval(msg.sender, spender, _allowance[msg.sender][spender]);\n\n        return true;\n    }\n\n    /**\n     * @notice Transfer the given amount from sender (caller) to recipient\n     * @dev _move emits a Transfer event if successful\n     * @param recipient - entity receiving the tokens\n     * @param amount - number of tokens being transferred\n     * @return bool - result of the transfer (will always be true if it doesn't revert)\n     */\n    function transfer(address recipient, uint amount) external override returns (bool) {\n        require(recipient != address(0), \"ERR_ZERO_ADDRESS\");\n\n        _move(msg.sender, recipient, amount);\n\n        return true;\n    }\n\n    /**\n     * @notice Transfer the given amount from sender to recipient\n     * @dev _move emits a Transfer event if successful; may also emit an Approval event\n     * @param sender - entity sending the tokens (must be caller or allowed to spend on behalf of caller)\n     * @param recipient - recipient of the tokens\n     * @param amount - number of tokens being transferred\n     * @return bool - result of the transfer (will always be true if it doesn't revert)\n     */\n    function transferFrom(address sender, address recipient, uint amount) external override returns (bool) {\n        require(recipient != address(0), \"ERR_ZERO_ADDRESS\");\n        require(msg.sender == sender || amount <= _allowance[sender][msg.sender], \"ERR_PCTOKEN_BAD_CALLER\");\n\n        _move(sender, recipient, amount);\n\n        // memoize for gas optimization\n        uint oldAllowance = _allowance[sender][msg.sender];\n\n        // If the sender is not the caller, adjust the allowance by the amount transferred\n        if (msg.sender != sender && oldAllowance != uint(-1)) {\n            _allowance[sender][msg.sender] = BalancerSafeMath.bsub(oldAllowance, amount);\n\n            emit Approval(msg.sender, recipient, _allowance[sender][msg.sender]);\n        }\n\n        return true;\n    }\n\n    // public functions\n\n    /**\n     * @notice Getter for the total supply\n     * @dev declared external for gas optimization\n     * @return uint - total number of tokens in existence\n     */\n    function totalSupply() external view override returns (uint) {\n        return varTotalSupply;\n    }\n\n    // Public functions\n\n    /**\n     * @dev Returns the name of the token.\n     *      We allow the user to set this name (as well as the symbol).\n     *      Alternatives are 1) A fixed string (original design)\n     *                       2) A fixed string plus the user-defined symbol\n     *                          return string(abi.encodePacked(NAME, \"-\", _symbol));\n     */\n    function name() external view returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() external view returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5,05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the value {ERC20} uses, unless {_setupDecimals} is\n     * called.\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() external pure returns (uint8) {\n        return DECIMALS;\n    }\n\n    // internal functions\n\n    // Mint an amount of new tokens, and add them to the balance (and total supply)\n    // Emit a transfer amount from the null address to this contract\n    function _mint(uint amount) internal virtual {\n        _balance[address(this)] = BalancerSafeMath.badd(_balance[address(this)], amount);\n        varTotalSupply = BalancerSafeMath.badd(varTotalSupply, amount);\n\n        emit Transfer(address(0), address(this), amount);\n    }\n\n    // Burn an amount of new tokens, and subtract them from the balance (and total supply)\n    // Emit a transfer amount from this contract to the null address\n    function _burn(uint amount) internal virtual {\n        // Can't burn more than we have\n        // Remove require for gas optimization - bsub will revert on underflow\n        // require(_balance[address(this)] >= amount, \"ERR_INSUFFICIENT_BAL\");\n\n        _balance[address(this)] = BalancerSafeMath.bsub(_balance[address(this)], amount);\n        varTotalSupply = BalancerSafeMath.bsub(varTotalSupply, amount);\n\n        emit Transfer(address(this), address(0), amount);\n    }\n\n    // Transfer tokens from sender to recipient\n    // Adjust balances, and emit a Transfer event\n    function _move(address sender, address recipient, uint amount) internal virtual {\n        // Can't send more than sender has\n        // Remove require for gas optimization - bsub will revert on underflow\n        // require(_balance[sender] >= amount, \"ERR_INSUFFICIENT_BAL\");\n\n        _balance[sender] = BalancerSafeMath.bsub(_balance[sender], amount);\n        _balance[recipient] = BalancerSafeMath.badd(_balance[recipient], amount);\n\n        emit Transfer(sender, recipient, amount);\n    }\n\n    // Transfer from this contract to recipient\n    // Emits a transfer event if successful\n    function _push(address recipient, uint amount) internal {\n        _move(address(this), recipient, amount);\n    }\n\n    // Transfer from recipient to this contract\n    // Emits a transfer event if successful\n    function _pull(address sender, uint amount) internal {\n        _move(sender, address(this), amount);\n    }\n}\n"
        },
        "./contracts/configurable-rights-pool/libraries/BalancerSafeMath.sol": {
            "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.6.12;\n\n\n// Imports\n\nimport \"./BalancerConstants.sol\";\n\n/**\n * @author Balancer Labs\n * @title SafeMath - wrap Solidity operators to prevent underflow/overflow\n * @dev badd and bsub are basically identical to OpenZeppelin SafeMath; mul/div have extra checks\n */\nlibrary BalancerSafeMath {\n    /**\n     * @notice Safe addition\n     * @param a - first operand\n     * @param b - second operand\n     * @dev if we are adding b to a, the resulting sum must be greater than a\n     * @return - sum of operands; throws if overflow\n     */\n    function badd(uint a, uint b) internal pure returns (uint) {\n        uint c = a + b;\n        require(c >= a, \"ERR_ADD_OVERFLOW\");\n        return c;\n    }\n\n    /**\n     * @notice Safe unsigned subtraction\n     * @param a - first operand\n     * @param b - second operand\n     * @dev Do a signed subtraction, and check that it produces a positive value\n     *      (i.e., a - b is valid if b <= a)\n     * @return - a - b; throws if underflow\n     */\n    function bsub(uint a, uint b) internal pure returns (uint) {\n        (uint c, bool negativeResult) = bsubSign(a, b);\n        require(!negativeResult, \"ERR_SUB_UNDERFLOW\");\n        return c;\n    }\n\n    /**\n     * @notice Safe signed subtraction\n     * @param a - first operand\n     * @param b - second operand\n     * @dev Do a signed subtraction\n     * @return - difference between a and b, and a flag indicating a negative result\n     *           (i.e., a - b if a is greater than or equal to b; otherwise b - a)\n     */\n    function bsubSign(uint a, uint b) internal pure returns (uint, bool) {\n        if (b <= a) {\n            return (a - b, false);\n        } else {\n            return (b - a, true);\n        }\n    }\n\n    /**\n     * @notice Safe multiplication\n     * @param a - first operand\n     * @param b - second operand\n     * @dev Multiply safely (and efficiently), rounding down\n     * @return - product of operands; throws if overflow or rounding error\n     */\n    function bmul(uint a, uint b) internal pure returns (uint) {\n        // Gas optimization (see github.com/OpenZeppelin/openzeppelin-contracts/pull/522)\n        if (a == 0) {\n            return 0;\n        }\n\n        // Standard overflow check: a/a*b=b\n        uint c0 = a * b;\n        require(c0 / a == b, \"ERR_MUL_OVERFLOW\");\n\n        // Round to 0 if x*y < BONE/2?\n        uint c1 = c0 + (BalancerConstants.BONE / 2);\n        require(c1 >= c0, \"ERR_MUL_OVERFLOW\");\n        uint c2 = c1 / BalancerConstants.BONE;\n        return c2;\n    }\n\n    /**\n     * @notice Safe division\n     * @param dividend - first operand\n     * @param divisor - second operand\n     * @dev Divide safely (and efficiently), rounding down\n     * @return - quotient; throws if overflow or rounding error\n     */\n    function bdiv(uint dividend, uint divisor) internal pure returns (uint) {\n        require(divisor != 0, \"ERR_DIV_ZERO\");\n\n        // Gas optimization\n        if (dividend == 0){\n            return 0;\n        }\n\n        uint c0 = dividend * BalancerConstants.BONE;\n        require(c0 / dividend == BalancerConstants.BONE, \"ERR_DIV_INTERNAL\"); // bmul overflow\n\n        uint c1 = c0 + (divisor / 2);\n        require(c1 >= c0, \"ERR_DIV_INTERNAL\"); //  badd require\n\n        uint c2 = c1 / divisor;\n        return c2;\n    }\n\n    /**\n     * @notice Safe unsigned integer modulo\n     * @dev Returns the remainder of dividing two unsigned integers.\n     *      Reverts when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * @param dividend - first operand\n     * @param divisor - second operand -- cannot be zero\n     * @return - quotient; throws if overflow or rounding error\n     */\n    function bmod(uint dividend, uint divisor) internal pure returns (uint) {\n        require(divisor != 0, \"ERR_MODULO_BY_ZERO\");\n\n        return dividend % divisor;\n    }\n\n    /**\n     * @notice Safe unsigned integer max\n     * @dev Returns the greater of the two input values\n     *\n     * @param a - first operand\n     * @param b - second operand\n     * @return - the maximum of a and b\n     */\n    function bmax(uint a, uint b) internal pure returns (uint) {\n        return a >= b ? a : b;\n    }\n\n    /**\n     * @notice Safe unsigned integer min\n     * @dev returns b, if b < a; otherwise returns a\n     *\n     * @param a - first operand\n     * @param b - second operand\n     * @return - the lesser of the two input values\n     */\n    function bmin(uint a, uint b) internal pure returns (uint) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @notice Safe unsigned integer average\n     * @dev Guard against (a+b) overflow by dividing each operand separately\n     *\n     * @param a - first operand\n     * @param b - second operand\n     * @return - the average of the two values\n     */\n    function baverage(uint a, uint b) internal pure returns (uint) {\n        // (a + b) / 2 can overflow, so we distribute\n        return (a / 2) + (b / 2) + ((a % 2 + b % 2) / 2);\n    }\n\n    /**\n     * @notice Babylonian square root implementation\n     * @dev (https://en.wikipedia.org/wiki/Methods_of_computing_square_roots#Babylonian_method)\n     * @param y - operand\n     * @return z - the square root result\n     */\n    function sqrt(uint y) internal pure returns (uint z) {\n        if (y > 3) {\n            z = y;\n            uint x = y / 2 + 1;\n            while (x < z) {\n                z = x;\n                x = (y / x + x) / 2;\n            }\n        }\n        else if (y != 0) {\n            z = 1;\n        }\n    }\n}\n"
        },
        "./contracts/configurable-rights-pool/libraries/BalancerConstants.sol": {
            "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.6.12;\n\n/**\n * @author Balancer Labs\n * @title Put all the constants in one place\n */\n\nlibrary BalancerConstants {\n    // State variables (must be constant in a library)\n\n    // B \"ONE\" - all math is in the \"realm\" of 10 ** 18;\n    // where numeric 1 = 10 ** 18\n    uint public constant BONE = 10**18;\n    uint public constant MIN_WEIGHT = BONE;\n    uint public constant MAX_WEIGHT = BONE * 50;\n    uint public constant MAX_TOTAL_WEIGHT = BONE * 50;\n    uint public constant MIN_BALANCE = BONE / 10**6;\n    uint public constant MAX_BALANCE = BONE * 10**12;\n    uint public constant MIN_POOL_SUPPLY = BONE * 100;\n    uint public constant MAX_POOL_SUPPLY = BONE * 10**9;\n    uint public constant MIN_FEE = BONE / 10**6;\n    uint public constant MAX_FEE = BONE / 10;\n    // EXIT_FEE must always be zero, or ConfigurableRightsPool._pushUnderlying will fail\n    uint public constant EXIT_FEE = 0;\n    uint public constant MAX_IN_RATIO = BONE / 2;\n    uint public constant MAX_OUT_RATIO = (BONE / 3) + 1 wei;\n    // Must match BConst.MIN_BOUND_TOKENS and BConst.MAX_BOUND_TOKENS\n    uint public constant MIN_ASSET_LIMIT = 2;\n    uint public constant MAX_ASSET_LIMIT = 8;\n    uint public constant MAX_UINT = uint(-1);\n}\n"
        },
        "./contracts/configurable-rights-pool/interfaces/IERC20.sol": {
            "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.6.12;\n\n// Interface declarations\n\n/* solhint-disable func-order */\n\ninterface IERC20 {\n    // Emitted when the allowance of a spender for an owner is set by a call to approve.\n    // Value is the new allowance\n    event Approval(address indexed owner, address indexed spender, uint value);\n\n    // Emitted when value tokens are moved from one account (from) to another (to).\n    // Note that value may be zero\n    event Transfer(address indexed from, address indexed to, uint value);\n\n    // Returns the amount of tokens in existence\n    function totalSupply() external view returns (uint);\n\n    // Returns the amount of tokens owned by account\n    function balanceOf(address account) external view returns (uint);\n\n    // Returns the remaining number of tokens that spender will be allowed to spend on behalf of owner\n    // through transferFrom. This is zero by default\n    // This value changes when approve or transferFrom are called\n    function allowance(address owner, address spender) external view returns (uint);\n\n    // Sets amount as the allowance of spender over the caller’s tokens\n    // Returns a boolean value indicating whether the operation succeeded\n    // Emits an Approval event.\n    function approve(address spender, uint amount) external returns (bool);\n\n    // Moves amount tokens from the caller’s account to recipient\n    // Returns a boolean value indicating whether the operation succeeded\n    // Emits a Transfer event.\n    function transfer(address recipient, uint amount) external returns (bool);\n\n    // Moves amount tokens from sender to recipient using the allowance mechanism\n    // Amount is then deducted from the caller’s allowance\n    // Returns a boolean value indicating whether the operation succeeded\n    // Emits a Transfer event\n    function transferFrom(address sender, address recipient, uint amount) external returns (bool);\n}\n"
        }
    },
    "settings": {
        "metadata": {
            "useLiteralContent": true
        },
        "optimizer": {
            "enabled": true,
            "runs": 200
        },
        "outputSelection": {
            "*": {
                "*": [
                    "abi",
                    "evm.bytecode",
                    "evm.deployedBytecode",
                    "evm.methodIdentifiers"
                ],
                "": [
                    "id",
                    "ast"
                ]
            }
        }
    }
}