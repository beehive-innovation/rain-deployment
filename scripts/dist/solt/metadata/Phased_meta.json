{
    "metadata": "{\"compiler\":{\"version\":\"0.6.12+commit.27d51765\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint32\",\"name\":\"newPhaseBlock_\",\"type\":\"uint32\"}],\"name\":\"PhaseShiftScheduled\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"UNINITIALIZED\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint32[8]\",\"name\":\"phaseBlocks_\",\"type\":\"uint32[8]\"},{\"internalType\":\"enum Phase\",\"name\":\"phase_\",\"type\":\"uint8\"}],\"name\":\"blockNumberForPhase\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"currentPhase\",\"outputs\":[{\"internalType\":\"enum Phase\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint32[8]\",\"name\":\"phaseBlocks_\",\"type\":\"uint32[8]\"},{\"internalType\":\"uint32\",\"name\":\"blockNumber_\",\"type\":\"uint32\"}],\"name\":\"phaseAtBlockNumber\",\"outputs\":[{\"internalType\":\"enum Phase\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"phaseBlocks\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"}],\"devdoc\":{\"details\":\"`Phased` contracts have a defined timeline with available functionality grouped into phases. Every `Phased` contract starts at `Phase.ZERO` and moves sequentially through phases `ONE` to `EIGHT`. Every `Phase` other than `Phase.ZERO` is optional, there is no requirement that all 9 phases are implemented. Phases can never be revisited, the inheriting contract always moves through each achieved phase linearly. This is enforced by only allowing `scheduleNextPhase` to be called once per phase. It is possible to call `scheduleNextPhase` several times in a single block but the `block.number` for each phase must be reached each time to schedule the next phase. Importantly there are events and several modifiers and checks available to ensure that functionality is limited to the current phase. The full history of each phase shift block is recorded as a fixed size array of `uint32`.\",\"kind\":\"dev\",\"methods\":{\"blockNumberForPhase(uint32[8],uint8)\":{\"params\":{\"phaseBlocks_\":\"Fixed array of phase blocks to compare against.\",\"phase_\":\"Determine the relevant block number for this phase.\"},\"returns\":{\"_0\":\"The block number for the phase according to the phase blocks         list, as uint32.\"}},\"phaseAtBlockNumber(uint32[8],uint32)\":{\"params\":{\"blockNumber_\":\"Determine the relevant phase relative to this block number.\",\"phaseBlocks_\":\"Fixed array of phase blocks to compare against.\"},\"returns\":{\"_0\":\"The \\\"current\\\" phase relative to the block number and phase blocks list.\"}}},\"title\":\"Phased\",\"version\":1},\"userdoc\":{\"events\":{\"PhaseShiftScheduled(uint32)\":{\"notice\":\"`PhaseShiftScheduled` is emitted when the next phase is scheduled.\"}},\"kind\":\"user\",\"methods\":{\"UNINITIALIZED()\":{\"notice\":\"Every phase block starts uninitialized. Only uninitialized blocks can be set by the phase scheduler.\"},\"blockNumberForPhase(uint32[8],uint8)\":{\"notice\":\"Pure function to reduce an array of phase blocks and phase to a specific block number. `Phase.ZERO` will always return block `0`. Every other phase will map to a block number in `phaseBlocks_`.\"},\"currentPhase()\":{\"notice\":\"Impure read-only function to return the \\\"current\\\" phase from internal contract state. Simply wraps `phaseAtBlockNumber` for current values of `phaseBlocks` and `block.number`.\"},\"phaseAtBlockNumber(uint32[8],uint32)\":{\"notice\":\"Pure function to reduce an array of phase blocks and block number to a specific `Phase`. The phase will be the highest attained even if several phases have the same block number. If every phase block is after the block number then `Phase.ZERO` is returned. If every phase block is before the block number then `Phase.EIGHT` is returned.\"},\"phaseBlocks(uint256)\":{\"notice\":\"8 phases each as 32 bits to fit a single 32 byte word.\"}},\"notice\":\"`Phased` is an abstract contract that defines up to `9` phases that an implementing contract moves through. `Phase.ZERO` is always the first phase and does not, and cannot, be set expicitly. Effectively it is implied that `Phase.ZERO` has been active since block zero. Each subsequent phase `Phase.ONE` through `Phase.EIGHT` must be scheduled sequentially and explicitly at a block number. Only the immediate next phase can be scheduled with `scheduleNextPhase`, it is not possible to schedule multiple phases ahead. Multiple phases can be scheduled in a single block if each scheduled phase is scheduled for the current block. Several utility functions and modifiers are provided. A single hook `_beforeScheduleNextPhase` is provided so contracts can implement additional phase shift checks. One event `PhaseShiftScheduled` is emitted each time a phase shift is scheduled (not when the scheduled phase is reached).\",\"version\":1}},\"settings\":{\"compilationTarget\":{\"./contracts/phased/Phased.sol\":\"Phased\"},\"evmVersion\":\"istanbul\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":100000},\"remappings\":[]},\"sources\":{\"./contracts/phased/Phased.sol\":{\"content\":\"// SPDX-License-Identifier: CAL\\npragma solidity ^0.6.12;\\n\\n/// Defines all possible phases.\\n/// `Phased` begins in `Phase.ZERO` and moves through each phase sequentially.\\nenum Phase {\\n    ZERO,\\n    ONE,\\n    TWO,\\n    THREE,\\n    FOUR,\\n    FIVE,\\n    SIX,\\n    SEVEN,\\n    EIGHT\\n}\\n\\n/// @title Phased\\n/// @notice `Phased` is an abstract contract that defines up to `9` phases that\\n/// an implementing contract moves through.\\n///\\n/// `Phase.ZERO` is always the first phase and does not, and cannot, be set\\n/// expicitly. Effectively it is implied that `Phase.ZERO` has been active\\n/// since block zero.\\n///\\n/// Each subsequent phase `Phase.ONE` through `Phase.EIGHT` must be\\n/// scheduled sequentially and explicitly at a block number.\\n///\\n/// Only the immediate next phase can be scheduled with `scheduleNextPhase`,\\n/// it is not possible to schedule multiple phases ahead.\\n///\\n/// Multiple phases can be scheduled in a single block if each scheduled phase\\n/// is scheduled for the current block.\\n///\\n/// Several utility functions and modifiers are provided.\\n///\\n/// A single hook `_beforeScheduleNextPhase` is provided so contracts can\\n/// implement additional phase shift checks.\\n///\\n/// One event `PhaseShiftScheduled` is emitted each time a phase shift is\\n/// scheduled (not when the scheduled phase is reached).\\n///\\n/// @dev `Phased` contracts have a defined timeline with available\\n/// functionality grouped into phases.\\n/// Every `Phased` contract starts at `Phase.ZERO` and moves sequentially\\n/// through phases `ONE` to `EIGHT`.\\n/// Every `Phase` other than `Phase.ZERO` is optional, there is no requirement\\n/// that all 9 phases are implemented.\\n/// Phases can never be revisited, the inheriting contract always moves through\\n/// each achieved phase linearly.\\n/// This is enforced by only allowing `scheduleNextPhase` to be called once per\\n/// phase.\\n/// It is possible to call `scheduleNextPhase` several times in a single block\\n/// but the `block.number` for each phase must be reached each time to schedule\\n/// the next phase.\\n/// Importantly there are events and several modifiers and checks available to\\n/// ensure that functionality is limited to the current phase.\\n/// The full history of each phase shift block is recorded as a fixed size\\n/// array of `uint32`.\\nabstract contract Phased {\\n    /// Every phase block starts uninitialized.\\n    /// Only uninitialized blocks can be set by the phase scheduler.\\n    uint32 constant public UNINITIALIZED = uint32(-1);\\n\\n    /// `PhaseShiftScheduled` is emitted when the next phase is scheduled.\\n    event PhaseShiftScheduled(uint32 indexed newPhaseBlock_);\\n\\n    /// 8 phases each as 32 bits to fit a single 32 byte word.\\n    uint32[8] public phaseBlocks = [\\n        UNINITIALIZED,\\n        UNINITIALIZED,\\n        UNINITIALIZED,\\n        UNINITIALIZED,\\n        UNINITIALIZED,\\n        UNINITIALIZED,\\n        UNINITIALIZED,\\n        UNINITIALIZED\\n    ];\\n\\n    /// Pure function to reduce an array of phase blocks and block number to a\\n    /// specific `Phase`.\\n    /// The phase will be the highest attained even if several phases have the\\n    /// same block number.\\n    /// If every phase block is after the block number then `Phase.ZERO` is\\n    /// returned.\\n    /// If every phase block is before the block number then `Phase.EIGHT` is\\n    /// returned.\\n    /// @param phaseBlocks_ Fixed array of phase blocks to compare against.\\n    /// @param blockNumber_ Determine the relevant phase relative to this block\\n    /// number.\\n    /// @return The \\\"current\\\" phase relative to the block number and phase\\n    /// blocks list.\\n    function phaseAtBlockNumber(\\n        uint32[8] memory phaseBlocks_,\\n        uint32 blockNumber_\\n    )\\n        public\\n        pure\\n        returns(Phase)\\n    {\\n        for(uint i_ = 0; i_<8; i_++) {\\n            if (blockNumber_ < phaseBlocks_[i_]) {\\n                return Phase(i_);\\n            }\\n        }\\n        return Phase(8);\\n    }\\n\\n    /// Pure function to reduce an array of phase blocks and phase to a\\n    /// specific block number.\\n    /// `Phase.ZERO` will always return block `0`.\\n    /// Every other phase will map to a block number in `phaseBlocks_`.\\n    /// @param phaseBlocks_ Fixed array of phase blocks to compare against.\\n    /// @param phase_ Determine the relevant block number for this phase.\\n    /// @return The block number for the phase according to the phase blocks\\n    ///         list, as uint32.\\n    function blockNumberForPhase(uint32[8] calldata phaseBlocks_, Phase phase_)\\n        external\\n        pure\\n        returns(uint32)\\n    {\\n        return phase_ > Phase.ZERO ? phaseBlocks_[uint(phase_) - 1] : 0;\\n    }\\n\\n    /// Impure read-only function to return the \\\"current\\\" phase from internal\\n    /// contract state.\\n    /// Simply wraps `phaseAtBlockNumber` for current values of `phaseBlocks`\\n    /// and `block.number`.\\n    function currentPhase() public view returns (Phase) {\\n        return phaseAtBlockNumber(phaseBlocks, uint32(block.number));\\n    }\\n\\n    /// Modifies functions to only be callable in a specific phase.\\n    /// @param phase_ Modified functions can only be called during this phase.\\n    modifier onlyPhase(Phase phase_) {\\n        require(currentPhase() == phase_, \\\"BAD_PHASE\\\");\\n        _;\\n    }\\n\\n    /// Modifies functions to only be callable in a specific phase OR if the\\n    /// specified phase has passed.\\n    /// @param phase_ Modified function only callable during or after this\\n    /// phase.\\n    modifier onlyAtLeastPhase(Phase phase_) {\\n        require(currentPhase() >= phase_, \\\"MIN_PHASE\\\");\\n        _;\\n    }\\n\\n    /// Writes the block for the next phase.\\n    /// Only uninitialized blocks can be written to.\\n    /// Only the immediate next phase relative to `currentPhase` can be written\\n    /// to.\\n    /// Emits `PhaseShiftScheduled` with the next phase block.\\n    /// @param nextPhaseBlock_ The block for the next phase.\\n    function scheduleNextPhase(uint32 nextPhaseBlock_) internal {\\n        require(uint32(block.number) <= nextPhaseBlock_, \\\"NEXT_BLOCK_PAST\\\");\\n        require(nextPhaseBlock_ < UNINITIALIZED, \\\"NEXT_BLOCK_UNINITIALIZED\\\");\\n\\n        // The next index is the current phase because `Phase.ZERO` doesn't\\n        // exist as an index.\\n        uint nextIndex_ = uint(currentPhase());\\n        require(UNINITIALIZED == phaseBlocks[nextIndex_], \\\"NEXT_BLOCK_SET\\\");\\n\\n        _beforeScheduleNextPhase(nextPhaseBlock_);\\n        phaseBlocks[nextIndex_] = nextPhaseBlock_;\\n\\n        emit PhaseShiftScheduled(nextPhaseBlock_);\\n    }\\n\\n    /// Hook called before scheduling the next phase.\\n    /// Useful to apply additional constraints or state changes on a phase\\n    /// change.\\n    /// Note this is called when scheduling the phase change, not on the block\\n    /// the phase change occurs.\\n    /// This is called before the phase change so that all functionality that\\n    /// is behind a phase gate is still available at the moment of applying the\\n    /// hook for scheduling the next phase.\\n    /// @param nextPhaseBlock_ The block for the next phase.\\n    function _beforeScheduleNextPhase(uint32 nextPhaseBlock_)\\n        internal\\n        virtual\\n    { } //solhint-disable-line no-empty-blocks\\n}\",\"keccak256\":\"0xa0b65b5b11a394435a0571d1b7ef1e065fd094258989e42fddd6377fd92e0f4d\",\"license\":\"CAL\"}},\"version\":1}"
} 